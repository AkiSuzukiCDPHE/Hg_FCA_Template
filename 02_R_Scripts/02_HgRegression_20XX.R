# R SCRIPT FOR DETERMINING LENGTH/CONCENTRATION RELATIONSHIPS FOR MERCURY


library(ggplot2)
library(dplyr)
library(broom)
# library(ggpubr)
library(readr)
library("tidyverse")

# Use the "HgData_Clean" data frame from the cleaning R script

# Turn off scientific notation
options(scipen = 999)

# Select the unique names of the waterbodies and save them to a vector called "Waterbodies"
Waterbodies = as.data.frame((HgData_Clean %>% select(Waterbody) %>% unique()))

# Select the unique name of the species and save to a vector called "Species"
Species = as.data.frame(HgData_Clean %>% select(Species_Codes) %>% unique())

# Filter the Species vector for the predator fish
Species = Species %>% filter(Species_Codes %in% c("NPK", "SMB", "LMB", "WAL", "SAG", "SGR"))

# Create a new data frame for running the regression which filters out non-detect values.
# Non-detect values result in an R2 of 1 because all results values are the same (1/2 the MDL). 
# Therefore these samples should not be included because they will produce an artificially
# strong relationship between length and concentration.
Hg_Length_Regression = HgData_Clean %>% filter(Qualifier != "<")

# Use the is.na function to check that NA values in the Qualifier column are included in the new regression dataframe.
NA_Data = HgData_Clean %>% filter(is.na(HgData_Clean$Qualifier))

# Merge the regression data frame and the NA_Data data frame. This data frame includes all
# rows except those where Qualifier = "<"
Hg_Length_Regression = bind_rows(Hg_Length_Regression, NA_Data)

# Build an empty data frame called Hg_Reg_Output. This data frame will store the
# output from the for loops function
Hg_Reg_Output <- as.data.frame(matrix(nrow = 1, ncol =7))

# Name the columns in Hg_Reg_Output
colnames(Hg_Reg_Output) <- c("N", "Waterbody","Species", "R2","Pvalue","Intercept","Length_Inches")

# write the nested for loop - this loop iterates through all waterbodies and all species
# and runs a regression equation to evaluate the relationship between concentration and length.

# The for loop runs through however many items are in a vector:
# This i loop runs through however many items are in Waterbodies
# This J loop runs through however many items are in Species

#Testing out running through only 3 waterbodies and 3 species to make sure the for loop works
# i = 3
# j = 3

#Testing out only looping through the first 5 values of waterbodies and species
  #for (i in 1:5) { 
    #for(j in 1:5){

#for (i in 1:nrow(Waterbodies)): This sets up a loop that will iterate over the values from 1 to the
#number of rows in Waterbodies.The loop variable i will take on each of these values during each iteration
#of the loop.

#for (j in 1:nrow(Species)): This sets up another loop inside the outer loop. The loop variable j will
#take on values from 1 to the number of rows in Species during each iteration of the inner loop.


  for (i in 1:nrow(Waterbodies)) { 
    for(j in 1:nrow(Species)){
  
# Inside the loops, this code extracts the current waterbody and fish species from each iteration
#, storing them in variables wbody and fish.
    wbody <- Waterbodies[i,]
    fish <- Species[j,]
    
# Create a new data frame, "reg_data," by filtering the Hg_Length_Regression data frame based on the current waterbody and fish species
    reg_data <- Hg_Length_Regression %>% filter(Waterbody == wbody & Species_Codes == fish)
    
# lm() function will error out if the data frame has no rows. 
    
# If the filtered data has at least 10 rows, it performs linear regression (lm) on the data, this filters
# out a minimum sample size for the regression model.
# Run the model for the relationship between length
# and concentration for each iteration of the for loop
    
    if(nrow(reg_data) >= 10) {
      Hg_LinearModel = lm(Result ~ Length_Inches, data = reg_data)
      
# This code prints some information about the current iteration (number of rows, waterbody, fish species,
# and summary statistics of the regression model).
      
      print(nrow(reg_data))
      print(wbody)
      print(fish)
      print(summary(Hg_LinearModel))
      
      N <- nrow(reg_data)
      r2 <- summary(Hg_LinearModel)$r.squared
      
# This code uses brackets with numbers to create variables by indexing into list of coefficients from the
# Hg_LinearModel object generated by the regression. The intercept is [1] and the slope is [2]
      
      intercept <- coef(Hg_LinearModel)[1]
      
      slope <- coef(Hg_LinearModel)[2]
      
# This code uses brackets with numbers to create variables by indexing into list of coefficients from the
# summary(Hg_Linear_Model). For example p.int= the p-value of the intercept found by indexing the
# coefficient variable (4th column) and 1st value
      
      p.int <- summary(Hg_LinearModel)$coefficients[,4][1]
      
      p.slope <- summary(Hg_LinearModel)$coefficients[,4][2]
      
# This code extracts relevant information from the regression results (e.g., R-squared, p-values,
# intercept, slope) and saves them in the empty data frame called Hg_Reg_Output.
# This data frame is being continuously appended with results from each iteration using bind_rows
      
# This output data frame is continuously appending each iteration from the for loops
# results into a empty data frame Hg_Reg_output
      out_df <- data.frame(N = N, Waterbody = wbody, Species = fish, R2 = r2, Pvalue = p.slope, Intercept = intercept, Length_Inches = slope)
      Hg_Reg_Output <- bind_rows(Hg_Reg_Output, out_df)
      
    }

# If the result from regression is zero, it skips to the next iteration of the outer loop using next instead of crashing the loop
    else {
      next
    }
    }
  }


# This line filters the Hg_Reg_Output data frame to keep only those rows where the value in
# the column N (representing the sample size) is not NA (not missing).
# is.na(Hg_Reg_Output$N) == FALSE returns TRUE for rows where the value in the N column is not NA, and
# FALSE for rows where it is NA.
# The filter function is then used to keep only those rows where the condition is TRUE i.e. where the N
# column has real values.
Hg_Reg_Output = Hg_Reg_Output %>% filter(is.na(Hg_Reg_Output$N) == FALSE)


# R2 > .4: This condition retains rows where the R-squared value is greater than 0.4.
# P-value < .05: This condition retains rows where the p-value is less than 0.05.
# The filter function is used to keep only those rows that satisfy both conditions (logical AND).
Hg_Reg_Output2 = Hg_Reg_Output %>% filter(R2 > .4 & Pvalue < .05)

# Create a numeric object for dependent variable
Children_1MealMonth = .26

# Solve for the independent variable of length using the rearranged formula: Y-a/b = x (x is predicted length)
# The formula calculates the predicted length (Pred_Length) based on the linear
# relationship defined by the intercept and length.
Hg_Reg_Output3 = Hg_Reg_Output2 %>% 
    mutate(Pred_Length = (Children_1MealMonth - Intercept)/Length_Inches)
  
# The first argument (select(Hg_Reg_Output3, Waterbody, Species, Pred_Length)) is a subset of
# the Hg_Reg_Output3 data frame, selecting only the columns Waterbody, Species, and Pred_Length.
# The second argument (by = c("Waterbody" = "Waterbody", "Species_Codes" = "Species")) specifies the
# columns to join on. It indicates that the Waterbody column in Hg_Length_Regression should be matched with
# the Waterbody column in the subset, and the Species_Codes column in Hg_Length_Regression should be
# matched with the Species column in the subset.
  Hg_Length_Regression2 = Hg_Length_Regression %>% 
  left_join(select(Hg_Reg_Output3, Waterbody, Species, Pred_Length),
            by = c("Waterbody" = "Waterbody", "Species_Codes" = "Species")
            )

# This R code is filtering a data frame (Hg_Length_Regression2) into two separate data frames:
# one containing rows where the Pred_Length column is not NA, and another containing rows where the
# Pred_Length column is NA. The purpose of this is to create a separate dataset for 
# (1) waterbodies where species have a relationship between length and concentration, and (2) waterbodies
# where species do not have a relationship between length and concentration

Samples_pred = Hg_Length_Regression2 %>% filter(is.na(Hg_Length_Regression2$Pred_Length) == FALSE)

Samples_notpred = Hg_Length_Regression2 %>% filter(is.na(Hg_Length_Regression2$Pred_Length) == TRUE)

# In the Samples_pred data frame where species have a relationship between length and concentration
# create  a new variable called "FishType" to categorize big and small fish species

Samples_pred2 = Samples_pred %>% 
  mutate(FishType = case_when(
      Length_Inches < Pred_Length ~ "Small",
      Length_Inches >= Pred_Length ~ "Big",
      TRUE ~ NA
  ))


# This line adds a new column named FishType to the Samples_notpred data frame and
# assigns the value NA to every row in this column. This is a common approach to initialize a
# new column with missing values.

Samples_notpred$FishType = NA

# The bind_rows function from the dplyr package is used to combine (row-bind) two data frames vertically.
# It appends the rows of the second data frame (Samples_pred2) to the rows of the first data frame
# (Samples_notpred). The result is stored in a new data frame called Samples_Final that has all rows from both data frames.

HgRegression_Final = bind_rows(Samples_notpred, Samples_pred2)

