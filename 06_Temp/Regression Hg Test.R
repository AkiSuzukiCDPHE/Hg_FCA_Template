library(ggplot2)
library(dplyr)
library(broom)
# library(ggpubr)
library(readr)
library("tidyverse")


#Upload the dataset as a csv
fishclean <- read_csv("C:/Users/oasuzuki/Documents/R/FCAs/Hg_FCA/03_Clean_Data/fishclean.csv")

#Turn off scientific notation
options(scipen = 999)

#Create a new data frame from the uploaded dataset

HgData_5 <- fishclean

#grab the unique name of the waterbodies and save to a vector called "Waterbodies"

Waterbodies = as.data.frame((HgData_5 %>% select(Waterbody) %>% unique()))

#grab the unique name of the species and save to a vector called "Species"

Species = as.data.frame(HgData_5 %>% select(Species_Codes) %>% unique())

#Filter the Species vector for the predator fish

Species = Species %>% filter(Species_Codes %in% c("NPK", "SMB", "LMB", "WAL", "SAG", "SGR"))

#Create a new data frame for running the regression which does not include non-detect values
#that create an R2 of 1 in the results bc all results values are the same replacement from the MDL

Hg_Length_Regression = HgData_5 %>% filter(Qualifier != "<")

#Using the is.na function to check that NA values without a qualifier are included in the new regression dataset

NA_Data = HgData_5 %>% filter(is.na(HgData_5$Qualifier))

#Merging the regression data frame and the NA_Data data frame

Hg_Length_Regression = bind_rows(Hg_Length_Regression, NA_Data)

# Build an empty data frame for Hg_Reg_Output and the for loops function

Hg_Reg_Output <- as.data.frame(matrix(nrow = 1, ncol =7))

colnames(Hg_Reg_Output) <- c("N", "Waterbody","Species", "R2","Pvalue","Intercept","Length_Inches")

#write nested for loop that says for each water body - for each species - run this regression regression
#Iterate through all of the waterbodies and species

#The four loop runs through however many items are in a vector
#This i loop runs through however many items are in Waterbodies
#This J loop runs through however many items are in Species

#Testing out running through only 3 waterbodies and 3 species to make sure the for loop works
# i = 3
# j = 3

#Testing out only looping through the first 5 values of waterbodies and species
#for (i in 1:5) { 
#for(j in 1:5){

#for (i in 1:nrow(Waterbodies)): This sets up a loop that will iterate over the values from 1 to the
#number of rows in Waterbodies.The loop variable i will take on each of these values during each iteration
#of the loop.

#for (j in 1:nrow(Species)): This sets up another loop inside the outer loop. The loop variable j will
#take on values from 1 to the number of rows in Species during each iteration of the inner loop.


for (i in 1:nrow(Waterbodies)) { 
  for(j in 1:nrow(Species)){
    
    # Inside the loops, this code extracts the current waterbody and fish species from each iteration
    #, storing them in variables wbody and fish.
    wbody <- Waterbodies[i,]
    fish <- Species[j,]
    
    # Creates a new data frame by filtering the Hg_Length_Regression data frame based on the current waterbody and fish species
    reg_data <- Hg_Length_Regression %>% filter(Waterbody == wbody & Species_Codes == fish)
    
    # lm() function will error out if the data frame has no rows. 
    
    # If the filtered data has at least 10 rows, it performs linear regression (lm) on the data, this filters
    # out a minimum sample size for the regression model.
    # Run the model for the relationship between length
    # and concentration for each iteration from the for loop
    
    if(nrow(reg_data) >= 10) {
      Hg_LinearModel = lm(Result ~ Length_Inches, data = reg_data)
      
      # This code prints some information about the current iteration (number of rows, waterbody, fish species,
      # and summary statistics of the regression model).
      
      print(nrow(reg_data))
      print(wbody)
      print(fish)
      print(summary(Hg_LinearModel))
      
      N <- nrow(reg_data)
      r2 <- summary(Hg_LinearModel)$r.squared
      
      # This code uses brackets with numbers to create variables by indexing into list of coefficients from the
      # Hg_LinearModel object generated by the regression. The intercept is [1] and the slope is [2]
      
      intercept <- coef(Hg_LinearModel)[1]
      
      slope <- coef(Hg_LinearModel)[2]
      
      # This code uses brackets with numbers to create variables by indexing into list of coefficients from the
      # summary(Hg_Linear_Model). For example p.int= the p-value of the intercept found by indexing the
      # coefficient variable (4th column) and 1st value
      
      p.int <- summary(Hg_LinearModel)$coefficients[,4][1]
      
      p.slope <- summary(Hg_LinearModel)$coefficients[,4][2]
      
      # This code extracts relevant information from the regression results (e.g., R-squared, p-values,
      # intercept, slope) and saves them in the empty data frame called Hg_Reg_Output.
      # This data frame is being continuously appended with results from each iteration using bind_rows
      
      # This output data frame is continuously appending each iteration from the for loops
      # results into a empty data frame Hg_Reg_output
      out_df <- data.frame(N = N, Waterbody = wbody, Species = fish, R2 = r2, Pvalue = p.slope, Intercept = intercept, Length_Inches = slope)
      Hg_Reg_Output <- bind_rows(Hg_Reg_Output, out_df)
      
    }
    
    # If the result from regression is zero, it skips to the next iteration of the outer loop using next insteda of crashing the loop
    else {
      next
    }
  }
}


# This line filters the Hg_Reg_Output data frame to keep only those rows where the value in the column N 
# (representing the sample size) is not NA (not missing).
# is.na(Hg_Reg_Output$N) == FALSE returns TRUE for rows where the value in the N column is not NA, and
# FALSE for rows where it is NA.
# The filter function is then used to keep only those rows where the condition is TRUE i.e. where the N
# column has real values.

Hg_Reg_Output = Hg_Reg_Output %>% filter(is.na(Hg_Reg_Output$N) == FALSE)


# R2 > .4: This condition retains rows where the R-squared value is greater than 0.4.
# Pvalue < .05: This condition retains rows where the p-value is less than 0.05.
# The filter function is used to keep only those rows that satisfy both conditions (logical AND).

Hg_Reg_Output2 = Hg_Reg_Output %>% filter(R2 > .4 & Pvalue < .05)

# Create a numeric object for dependent variable

Children_1Mo = .26

# Solve for the independent variable of length using the rearranged formula: Y-a/b = x (x is length)
# The formula calculates the predicted length (Pred_Length) based on the linear
# relationship defined by the intercept and length.

Hg_Reg_Output3 = Hg_Reg_Output2 %>% 
  mutate(
    Pred_Length = (Children_1Mo - Intercept)/Length_Inches)

# The first argument (select(Hg_Reg_Output3, Waterbody, Species, Pred_Length)) is a subset of
# the Hg_Reg_Output3 data frame, selecting only the columns Waterbody, Species, and Pred_Length.
# The second argument (by = c("Waterbody" = "Waterbody", "Species_Codes" = "Species")) specifies the
# columns to join on. It indicates that the Waterbody column in Hg_Length_Regression should be matched with
# the Waterbody column in the subset, and the Species_Codes column in Hg_Length_Regression should be
# matched with the Species column in the subset.

Hg_Length_Regression2 = Hg_Length_Regression %>% 
  left_join(select(Hg_Reg_Output3, Waterbody, Species, Pred_Length),
            by = c("Waterbody" = "Waterbody", "Species_Codes" = "Species")
  )

# This R code is filtering a data frame (Hg_Length_Regression2) into two separate data frames:
# one containing rows where the Pred_Length column is not NA, and another containing rows where the
# Pred_Length column is NA. The purpose of this is to create a separate dataset for 
# (1) waterbodies where species have a relationship between length and concentration, and (2) waterbodies
# where species do not have a relationship between length and concentration

Samples_pred = Hg_Length_Regression2 %>% filter(is.na(Hg_Length_Regression2$Pred_Length) == FALSE)

Samples_notpred = Hg_Length_Regression2 %>% filter(is.na(Hg_Length_Regression2$Pred_Length) == TRUE)

# In the Samples_pred data frame where species have a relationship between length and concentration
# create  a new variable called "FishType" to categorize big and small fish species

Samples_pred2 = Samples_pred %>% 
  mutate(
    FishType = case_when(
      Length_Inches < Pred_Length ~ "Small",
      Length_Inches >= Pred_Length ~ "Big",
      TRUE ~ NA
    ))

# This line adds a new column named FishType to the Samples_notpred data frame and
# assigns the value NA to every row in this column. A common approach to initialize a
# new column with missing values.

Samples_notpred$FishType = NA

# The bind_rows function from the dplyr package is used to combine (row-bind) two data frames vertically.
# It appends the rows of the second data frame (Samples_pred2) to the rows of the first data frame
# (Samples_notpred). The result is stored in a new data frame called Samples_Final that has all rows form both data frames.

HgRegression_Final = bind_rows(Samples_notpred, Samples_pred2)

Test  <- HgRegression_Final  %>% filter(Waterbody == "Horsetooth Reservoir", Species_Codes == "SMB")


